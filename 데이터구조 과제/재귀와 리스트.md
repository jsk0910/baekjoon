## 데이터 구조 1차 과제 - 재귀와 리스트  
재귀 - 11729, 2447, 5639  
리스트 - 1406, 1100, 20936  
  ***
#### 재귀
> ##### 11729번 - 하노이 탑 이동 순서
> > + url : https://www.acmicpc.net/problem/11729  
> > + 문제 내용  
> > ![image](https://user-images.githubusercontent.com/23286838/228575174-ddb8ce31-781a-47ba-bf5e-a1dc245c862f.png)  
> > + 입력
> > 첫째 줄에 첫 번째 장대에 쌓인 원판의 개수 N($1 \leq N \leq 20$)이 주어진다.  
> > + 출력
> > 첫째 줄에 원판을 옮긴 횟수 K가 출력된다.  
> > 두 번째 줄부터 수행과정을 출력한다. 두 정수 A, B를 출력한다. (A 번째 탑의 가장 위에 있는 원판을 B 번째 탑으로 옮긴다는 뜻이다.)  
> > + 코드  
> > ```python
> > N = int(input()) # 첫째 줄 값 입력
> > resultList = [] # 결과를 저장할 리스트
> > def hanoi(n, from_position, to_position, aux_position): 
> >   # n=개수, from_position=기존 위치, to_position=옮기고자 하는 목표 위치, aux_position=경유하는 막대
> >   if n == 1: # n이 1인 경우 = 마지막 경우(종료)
> >     resultList.append([from_position, to_position]) # 결과 리스트에 마지막으로 옮기는 위치 저장
> >     return # 함수 탈출
> >   hanoi(n - 1, from_position, aux_position, to_position) # 재귀, n-1, from에서 to를 경유하여 aux(임시)에 원판을 넣음
> >   resultList.append([from_position, to_position]) # 옮긴 과정을 결과 리스트에 저장
> >   hanoi(n - 1, aux_position, to_position, from_position) # 재귀, n-1, aux 막대에서 from을 경유하여 to 막대에 넣음
> > hanoi(N, 1, 3, 2) # 1번 막대를 from, 3번 막대를 to, 2번 막대를 aux로 함
> > print(len(resultList)) # 옮긴 횟수 k는 resultList의 길이와 같다
> > for i in resultList: 결과 리스트로부터 요소를 하나씩 받아서
> >  print(i[0], i[1]) # from이 A, to가 B로 출력
> > ```
> ##### 2447번 - 별 찍기  
> > + url : https://www.acmicpc.net/problem/2447  
> > + 문제 내용  
> > ![image](https://user-images.githubusercontent.com/23286838/228579548-34652dd8-b4a8-4e91-af77-b6823d60b347.png)  
> > + 입력  
> > 첫째 줄에 N이 주어진다. N은 3의 거듭제곱이다. 즉 어떤 정수 k에 대해 N=3k이며, 이때 1 ≤ k < 8이다.  
> > + 출력  
> > 첫째 줄부터 N번째 줄까지 별을 출력한다.  
> > + 예시 입력과 출력  
> > ![image](https://user-images.githubusercontent.com/23286838/228579926-8550f765-c156-4954-960d-2585523136f5.png)  
> > + 코드  
> > ```python
> > def draw(n): # draw 함수 -> 정수 N을 인자로 받는다
> >   if n == 1: # n=1인 경우
> >     return ['*'] # 리스트 ['*']를 리턴한다.
> >   stars = draw(n // 3) # stars에 draw(n//3)을 저장한다
> >   list1 = [] # 빈 리스트 list1을 생성한다
> >   
> >   for star in stars: # stars에 있는 star를 하나씩 가져와서
> >    list1.append(star * 3) # list1에 3개씩 저장한다.
> >   for star in stars: 
> >    list1.append(star + ' ' * (n // 3) + star) # 별 사이에 n//3 만큼 ' '를 넣는다.
> >   for star in stars:
> >    list1.append(star * 3) # 별을 3개씩 저장한다
> >   return list1
> > N = int(input())
> > print('\n'.join(draw(N))) # 한 칸씩 띄워서(밑으로) 출력한다
> > ```
> ##### 5639번 - 이진 검색 트리  
> > + url : https://www.acmicpc.net/problem/5639  
> > + 문제 내용  
> > ![image](https://user-images.githubusercontent.com/23286838/228583329-ff2f3faa-d149-45e0-b5af-465883fb7003.png)  
> > + 입력  
> > 트리를 전위 순회한 결과가 주어진다. 노드에 들어있는 키의 값은 106보다 작은 양의 정수이다. 모든 값은 한 줄에 하나씩 주어지며, 노드의 수는 10,000개 이하이다. 같은 키를 가지는 노드는 없다.  
> > + 출력
> > 입력으로 주어진 이진 검색 트리를 후위 순회한 결과를 한 줄에 하나씩 출력한다.  
> > + 코드  
> > ```python  
> > import sys
> > sys.setrecursionlimit(10**9)
> > tree = []  
> > 
> > while 1:
> >   try:
> >    num = int(input())
> >    tree.append(num)
> >   except:
> >    break
> > def postorder(lo, hi):
> >   if lo > hi:
> >    return
> >   mid = hi + 1
> >   for i in range(lo+1, hi+1):
> >     if tree[lo] < tree[i]:
> >       mid = i
> >       break
> >   postorder(lo + 1, mid - 1)
> >   postorder(mid, hi)
> >   print(tree[lo])
> > postorder(0, len(tree) - 1)
> > ```
